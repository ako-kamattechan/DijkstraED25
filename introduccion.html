<!DOCTYPE html>
<html lang="es-MX">

<link rel="stylesheet" href="project/theme.css" />
<head>
    <title>Introducción</title>


    <style>
        html,body {
            margin:0;
            padding:0;
            color:#e5e7eb;
            font:16px/1.6 sans-serif;

            overflow-y: auto;
            overflow-x: hidden;
        }

        main {
            max-width: 920px;
            margin: 48px auto;
            padding: 0 24px;
        }

        h1, h2, h3 {
            line-height: 1.25;
            margin: 0 0 16px
        }

        h1 {
            font-size: 1.8rem
        }

        h2 {
            font-size: 1.35rem;
            margin-top: 32px;
            border-left: 4px solid #efe644;
            padding-left: 10px
        }

        p {
            margin: 0 0 12px
        }

        ol {
            margin: 0 0 16px 20px
        }

        li {
            margin: 6px 0
        }

        .meta {
            color: #9ca3af;
            font-size: .95rem
        }

        .ref {
            padding: 16px;
            border-radius: 12px
        }

        code, kbd {
            background: #111827;
            padding: 2px 6px;
            border-radius: 6px
        }

        .small {
            font-size: .95rem;
            color: rgb(250, 138, 138);
        }

        a {
            color: #fca5a5;
            text-decoration: none
        }

        a:hover {
            text-decoration: underline
        }

        .section {
            margin-top: 28px
        }
    </style>
</head>
<body>
<main>

    <h1>2. Introducción</h1>

    <section class="section" id="apps">
        <h2>2.1 Teoría de grafos y representación de sistemas</h2>

        <ol>
            <li>Todo sistema puede representarse como un conjunto de entidades y relaciones.</li>
            <li>En informática, estas relaciones se modelan mediante <strong>grafos</strong>, estructuras G = (V, E) formadas por vértices y aristas.</li>
            <li>Cada arista puede asociarse a un <strong>peso</strong> que cuantifica costo, distancia o tiempo de transmisión.</li>
            <li>Un grafo ponderado permite analizar problemas de optimización en redes de transporte, comunicación o datos.</li>
            <li>La <strong>teoría de grafos</strong> provee el marco formal para estudiar tales estructuras y los algoritmos que operan sobre ellas (Gutiérrez &amp; Zuleta, 2024, pp. 9–15).</li>

            <li>En redes informáticas, los grafos modelan topologías físicas y lógicas: routers, enlaces y latencias.</li>
            <li>En compiladores, describen flujos de control y dependencias entre bloques de código.</li>
            <li>En ingeniería de software, expresan relaciones de componentes, dependencias o jerarquías.</li>
            <li>Estas representaciones permiten aplicar técnicas algorítmicas que reducen complejidad, costo o redundancia.</li>

            <li>Dos problemas centrales emergen de esta abstracción:
                <br> a) el <strong>árbol de expansión mínima (MST)</strong>, que conecta todos los vértices minimizando el peso total, y
                <br> b) el <strong>camino más corto (SPP)</strong>, que determina la ruta de menor costo entre pares de nodos (Gutiérrez &amp; Zuleta, 2024, pp. 104–117).
            </li>
            <li>Ambos constituyen la base para algoritmos de enrutamiento, planificación y optimización combinatoria (Jordán et al., 2022).</li>
        </ol>
    </section>

    <embed src="project/software_svg.html" width="100%" height="600px" />

    <section class="section" id="dijkstra">
        <h2>2.2 El algoritmo de Dijkstra</h2>

        <ol>
            <li>El <strong>problema del camino más corto</strong> consiste en hallar, en un grafo ponderado con pesos no negativos, la distancia mínima desde un vértice origen "s" hacia todos los demás.</li>
            <li>Edsger W. Dijkstra formuló en 1959 un procedimiento greedy que resuelve este problema en tiempo O(V^2) o O((V + E) log V) con estructuras de prioridad adecuadas.</li>
            <li>El algoritmo parte de una asignación inicial de distancia infinita a todos los vértices excepto el origen, cuya distancia es 0.</li>
            <li>En cada iteración, selecciona el vértice con la menor distancia provisional y actualiza sus vecinos mediante <strong>relajación</strong> de aristas.</li>
            <li>El proceso se repite hasta que todas las distancias son definitivas (Gutiérrez &amp; Zuleta, 2024, p. 111).</li>

            <li>La estructura de datos utilizada influye en la eficiencia:
                <br>– con matriz de adyacencia, el tiempo es O(V^2).
                <br>– con cola de prioridad binaria o Fibonacci, O((V + E) log V).
            </li>
            <li>Esta complejidad lo hace adecuado para grafos medianos o grandes donde los pesos son no negativos y la topología es relativamente estática.</li>

            <li>Aplicaciones: enrutamiento (OSPF, IS-IS), planificación logística, SIG, y como caso base de algoritmos heurísticos como <strong>A*</strong>.</li>
            <li>Por su generalidad, Dijkstra representa un razonamiento determinista: a partir de pesos locales, infiere una estructura global de mínimos.</li>
            <li>Es un pilar de la computación algorítmica: la formalización matemática traduce sistemas complejos en decisiones óptimas reproducibles.</li>
        </ol>
    </section>

    <section class="section" id="refs">
        <h2>Bibliografía.</h2>
        <div class="ref">
            <p>Gutiérrez García, I., &amp; Zuleta Saldarriaga, Y. M. (2024). <em>Introducción a la teoría de grafos: conceptos, algoritmos y aplicaciones.</em> Universidad del Norte. (pp. 9–15, 104–117, 111).</p>
            <p>Jordán Lluch, C., Murillo Arcila, M., &amp; Seoane Sepúlveda, J. B. (2022). <em>Teoría de grafos y modelización. Problemas resueltos.</em> Ediciones Paraninfo.</p>
        </div>
    </section>

</main>
</body>
</html>
