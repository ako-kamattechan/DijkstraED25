<!DOCTYPE html>
<html lang="es-MX">

<link rel="stylesheet" href="project/theme.css" />
<head>
    <title>Introducción</title>


    <style>
        html,body {
            margin:0;
            padding:0;
            color:#e5e7eb;
            font:16px/1.6 sans-serif;

            overflow-y: auto;
            overflow-x: hidden;
        }

        main {
            max-width: 920px;
            margin: 48px auto;
            padding: 0 24px;
        }

        h1, h2, h3 {
            line-height: 1.25;
            margin: 0 0 16px
        }

        h1 {
            font-size: 2rem
        }

        h2 {
            font-size: 1.8rem;
            margin-top: 32px;
            border-left: 4px solid #efe644;
            padding-left: 10px
        }

        p {
            margin: 0 0 12px
        }

        ol {
            margin: 0 0 16px 20px
        }

        li {
            font-size: 1.5rem;
            margin: 6px 0
        }

        .meta {
            color: #9ca3af;
            font-size: .95rem
        }

        .ref {
            padding: 16px;
            border-radius: 12px
        }

        code, kbd {
            background: #111827;
            padding: 2px 6px;
            border-radius: 6px
        }

        .small {
            font-size: .95rem;
            color: rgb(250, 138, 138);
        }

        a {
            color: #fca5a5;
            text-decoration: none
        }

        a:hover {
            text-decoration: underline
        }

        .section {
            margin-top: 28px
        }

        .iframe-label{
            font-size: 1rem;
            font-weight: bold;
            font-family: "Helvetica Light", sans-serif;
            font-style: italic;
            position: relative;
            padding-left: 20em;
            filter: drop-shadow(2px 2px 3px #494949);
        }

    </style>
</head>
<body>
<main>

    <h1>2. Introducción</h1>

    <section class="section" id="apps">
        <h2>2.1 Teoría de grafos y representación de sistemas</h2>

        <ol>
            <li>Todo sistema puede representarse como un conjunto de entidades y relaciones.</li>
            <li>En informática, estas relaciones se modelan mediante <strong>grafos</strong>, estructuras G = (V, E) formadas por vértices y aristas.</li>
            <li>Cada arista puede asociarse a un <strong>peso</strong> que cuantifica costo, distancia o tiempo de transmisión.</li>
            <li>Un grafo ponderado permite analizar problemas de optimización en redes de transporte, comunicación o datos.</li>
            <li>La <strong>teoría de grafos</strong> provee el marco formal para estudiar tales estructuras y los algoritmos que operan sobre ellas (Gutiérrez &amp; Zuleta, 2024, pp. 9–15).</li>

            <li>En redes informáticas, los grafos modelan topologías físicas y lógicas: routers, enlaces y latencias.</li>
            <li>En compiladores, describen flujos de control y dependencias entre bloques de código.</li>
            <li>En ingeniería de software, expresan relaciones de componentes, dependencias o jerarquías.</li>
            <li>Estas representaciones permiten aplicar técnicas algorítmicas que reducen complejidad, costo o redundancia.</li>

            <li>Dos problemas centrales emergen de esta abstracción:
                <br> a) el <strong>árbol de expansión mínima (MST)</strong>, que conecta todos los vértices minimizando el peso total, y
                <br> b) el <strong>camino más corto (SPP)</strong>, que determina la ruta de menor costo entre pares de nodos (Gutiérrez &amp; Zuleta, 2024, pp. 104–117).
            </li>
            <li>Ambos constituyen la base para algoritmos de enrutamiento, planificación y optimización combinatoria (Jordán et al., 2022).</li>
        </ol>
    </section>

    <!-- Software_01 Wrapper -> [Iframe; Script] -->
    <!-- Graph [App State]; UI Hidden; Animation Loop  -->
    <iframe id="dijkstraApp"
            src="project/software_svg.html"
            width="1000"
            height="600"
            style="border:none;"
    ></iframe>
    <div class="iframe-label"> Algoritmo de Dijkstra aplicado a una Gráfica </div>

    <!-- Preset[Nodes; Edges]; Source; Loop True -->
    <script>
        window.addEventListener("DOMContentLoaded", () => {
            const iframe = document.getElementById("dijkstraApp");

            const preset = {
                nodes: [
                    {
                        "id": "A",
                        "x": 901.1103515625,
                        "y": 271.68609619140625
                    },
                    {
                        "id": "B",
                        "x": 439.09527587890625,
                        "y": 230.6717071533203
                    },
                    {
                        "id": "C",
                        "x": 433.0637512207031,
                        "y": 672.1795654296875
                    },
                    {
                        "id": "D",
                        "x": 624.8663330078125,
                        "y": 559.9931640625
                    },
                    {
                        "id": "E",
                        "x": 627.2789916992188,
                        "y": 387.491455078125
                    },
                    {
                        "id": "F",
                        "x": 886.6347045898438,
                        "y": 644.4345703125
                    },
                    {
                        "id": "G",
                        "x": 1178.5606689453125,
                        "y": 439.3625793457031
                    }
                ],
                edges: [
                    {
                        "a": "A",
                        "b": "B",
                        "w": 5
                    },
                    {
                        "a": "A",
                        "b": "E",
                        "w": 15
                    },
                    {
                        "a": "A",
                        "b": "D",
                        "w": 3
                    },
                    {
                        "a": "D",
                        "b": "C",
                        "w": 4
                    },
                    {
                        "a": "D",
                        "b": "F",
                        "w": 11
                    },
                    {
                        "a": "F",
                        "b": "G",
                        "w": 14
                    }
                ],
                sourceId: "A",
                loop: true
            };

            iframe.addEventListener("load", () => {
                iframe.contentWindow.postMessage({
                    type: "INIT_GRAPH",
                    payload: preset
                }, "*");

                iframe.contentWindow.postMessage({
                    type: "HIDE_UI"
                }, "*");

                iframe.contentWindow.postMessage({
                    type: "START"
                }, "*");
            });
        });
    </script>


    <section class="section" id="dijkstra">
        <h2>2.2 El algoritmo de Dijkstra</h2>

        <ol>
            <li>El <strong>problema del camino más corto</strong> consiste en hallar, en un grafo ponderado con pesos no negativos, la distancia mínima desde un vértice origen "s" hacia todos los demás.</li>
            <li>Edsger W. Dijkstra formuló en 1959 un procedimiento greedy que resuelve este problema en tiempo O(V^2) o O((V + E) log V) con estructuras de prioridad adecuadas.</li>
            <li>El algoritmo parte de una asignación inicial de distancia infinita a todos los vértices excepto el origen, cuya distancia es 0.</li>
            <li>En cada iteración, selecciona el vértice con la menor distancia provisional y actualiza sus vecinos mediante <strong>relajación</strong> de aristas.</li>
            <li>El proceso se repite hasta que todas las distancias son definitivas (Gutiérrez &amp; Zuleta, 2024, p. 111).</li>

            <li>La estructura de datos utilizada influye en la eficiencia:
                <br>– con matriz de adyacencia, el tiempo es O(V^2).
                <br>– con cola de prioridad binaria o Fibonacci, O((V + E) log V).
            </li>
            <li>Esta complejidad lo hace adecuado para grafos medianos o grandes donde los pesos son no negativos y la topología es relativamente estática.</li>

            <li>Aplicaciones: enrutamiento (OSPF, IS-IS), planificación logística, SIG, y como caso base de algoritmos heurísticos como <strong>A*</strong>.</li>
            <li>Por su generalidad, Dijkstra representa un razonamiento determinista: a partir de pesos locales, infiere una estructura global de mínimos.</li>
            <li>Es un pilar de la computación algorítmica: la formalización matemática traduce sistemas complejos en decisiones óptimas reproducibles.</li>
        </ol>
    </section>

    <section class="section" id="refs">
        <h2>Bibliografía.</h2>
        <div class="ref">
            <p>Gutiérrez García, I., &amp; Zuleta Saldarriaga, Y. M. (2024). <em>Introducción a la teoría de grafos: conceptos, algoritmos y aplicaciones.</em> Universidad del Norte. (pp. 9–15, 104–117, 111).</p>
            <p>Jordán Lluch, C., Murillo Arcila, M., &amp; Seoane Sepúlveda, J. B. (2022). <em>Teoría de grafos y modelización. Problemas resueltos.</em> Ediciones Paraninfo.</p>
        </div>
    </section>

</main>
</body>
</html>
