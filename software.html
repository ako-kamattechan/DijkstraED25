<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Algoritmo de Dijkstra</title>
<style>
  :root {
    --drawer-width: 400px;
    --drawer-bg: #0f1424;
  }
  body {
    margin: 0;
    background: #0b0f1a;
    color: #d1d5db;
    font-family: sans-serif;
    height: 100vh;
    overflow: hidden;
  }
  #canvas {
    display: block;
    background-image: url('a.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    cursor: crosshair;
  }

  /* Distances table */
  #sidebar {
    position: fixed;
    top: 0;
    right: 0;
    height: 100vh;
    width: var(--drawer-width);
    background: var(--drawer-bg);
    border-left: 1px solid #1f2740;
    padding: 10px;
    box-sizing: border-box;
    overflow-y: auto;
    transform: translateX(0%);
    transition: transform 0.28s ease;
    will-change: transform;
    z-index: 20;
  }
  #sidebar.open { transform: translateX(0%); }

  select, button {
    background: transparent;
    color: #ff4f4f;
    border: 1px solid #ff0000;
    border-radius: 5px;
    padding: 4px 8px;
    margin-bottom: 8px;
  }
  table { width: 100%; font-size: 12px; border-collapse: collapse; }
  th, td { border-bottom: 1px solid #1f2740; padding: 4px; text-align: left; }

  /* CSS for compatibility, but incomplete */
  #toggleSidebar {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 30;
    background: #1f2740;
    color: #fff;
    border: none;
    border-radius: 5px;
    padding: 6px 10px;
    cursor: pointer;
  }

</style>
</head>
<body>

<!-- Incomplete but used compatibility-->
<button id="toggleSidebar" hidden>Si lees esto, juega subahibi</button>



<canvas id="canvas"></canvas>

<div id="sidebar" class="open" aria-hidden="false">
  <div>
    <label>Inicio:</label>
    <select id="source"></select>
    <button id="reset">Reiniciar</button>
  </div>
  <table id="result">
    <thead><tr><th>Nodo</th><th>Distancia</th><th>Camino</th></tr></thead>
    <tbody></tbody>
  </table>
  <p style="font-size:11px;color:#9ca3af;margin-top:8px;">
    Click para añadir nodos. Arrastra desde un nodo para crear una conexión. Doble click en una arista para cambiar su valor.<br>
    Mantén presionado Shift para eliminar nodos/aristas.
  </p>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const sidebar = document.getElementById('sidebar');
const toggleBtn = document.getElementById('toggleSidebar');

let drawerOpen = false;



let W = 0, H = 0;

function sidebarWidth() {
  /* Obtain width to avoid bug with tracking */
  const cs = getComputedStyle(sidebar);
  return parseInt(cs.width, 10) || 0;
}


/* Incomplete code, used for compatibility */
function resizeCanvas() {
  const sw = drawerOpen ? sidebarWidth() : 0;
  canvas.width = Math.max(0, window.innerWidth - sw);
  canvas.height = window.innerHeight;
  W = canvas.width; H = canvas.height;
  draw();
}




/* Force synchronization to avoid tracking before the page loads */
window.addEventListener('load', () => {
  sidebar.getBoundingClientRect();           
  requestAnimationFrame(() => resizeCanvas()); 
});
window.addEventListener('resize', resizeCanvas);

sidebar.addEventListener('transitionend', (e) => {
  if (e.propertyName === 'transform') resizeCanvas();
});


/* I didn't implement this because of time */
toggleBtn.onclick = () => {
  drawerOpen = !drawerOpen;
  sidebar.classList.toggle('open', drawerOpen);
  toggleBtn.textContent = drawerOpen ? ' ' : ' ';
  sidebar.setAttribute('aria-hidden', (!drawerOpen).toString());

  resizeCanvas();
};

/* Dijkstra Algorithm */

let ctrl = false;
window.addEventListener('keydown', e => { if (e.key === 'Control') ctrl = true; if (e.key === 'Shift') shift = true; });
window.addEventListener('keyup',   e => { if (e.key === 'Control') ctrl = false; if (e.key === 'Shift') shift = false; });

const nodes = [];
const edges = [];
let linking = null;
let shift = false;
let sourceId = null;
const radius = 20;

const sourceSelect = document.getElementById('source');
const resultBody = document.querySelector('#result tbody');
const resetBtn = document.getElementById('reset');
resetBtn.onclick = resetAll;

canvas.addEventListener('click', e => {
  const x = e.offsetX, y = e.offsetY;
  if (shift) return;
  if (overNode(x, y) || overEdge(x, y)) return;
  if (nodes.length >= 12) { alert("Solo se permiten hasta 12 nodos."); return; }

  const name = nextName();
  nodes.push({ id: name, x, y });
  if (nodes.length === 1) sourceId = name;
  updateSourceList();
  draw();
});

let draggingNode = null;

canvas.addEventListener('mousedown', e => {
  const x = e.offsetX, y = e.offsetY;
  const n = getNode(x, y);

  if (ctrl && n) { draggingNode = n; return; }
  if (!ctrl && n) { linking = { from: n.id, x, y }; }
});
canvas.addEventListener('mousemove', e => {
  if (linking) { linking.x = e.offsetX; linking.y = e.offsetY; draw(); }
  if (draggingNode) { draggingNode.x = e.offsetX; draggingNode.y = e.offsetY; draw(); }
});
canvas.addEventListener('mouseup', e => {
  if (draggingNode) { draggingNode = null; draw(); return; }
  if (!linking) return;
  const n2 = getNode(e.offsetX, e.offsetY);
  if (n2 && n2.id !== linking.from) {
    const exists = edges.some(e =>
      (e.a === linking.from && e.b === n2.id) ||
      (e.b === linking.from && e.a === n2.id)
    );
    if (!exists) edges.push({ a: linking.from, b: n2.id, w: 1 });
  }
  linking = null; draw();
});

canvas.addEventListener('dblclick', e => {
  const eHit = getEdge(e.offsetX, e.offsetY);
  if (eHit) {
    const val = prompt('Peso de la arista:', eHit.w);
    if (val !== null && !isNaN(+val)) eHit.w = +val;
    draw();
  }
});

canvas.addEventListener('click', e => {
  if (!shift) return;
  const n = getNode(e.offsetX, e.offsetY);
  if (n) {
    const idx = nodes.indexOf(n);
    nodes.splice(idx, 1);
    for (let i = edges.length - 1; i >= 0; i--) {
      if (edges[i].a === n.id || edges[i].b === n.id) edges.splice(i, 1);
    }
    draw(); updateSourceList(); return;
  }
  const ed = getEdge(e.offsetX, e.offsetY);
  if (ed) { edges.splice(edges.indexOf(ed), 1); draw(); }
});

function getNode(x, y) { return nodes.find(n => (x - n.x)**2 + (y - n.y)**2 <= radius**2); }
function overNode(x, y) { return !!getNode(x, y); }
function getEdge(x, y) {
  for (const e of edges) {
    const n1 = nodes.find(n => n.id === e.a);
    const n2 = nodes.find(n => n.id === e.b);
    if (!n1 || !n2) continue;
    const d = pointLineDist({x, y}, n1, n2);
    if (d < 6) return e;
  } return null;
}
function overEdge(x, y) { return !!getEdge(x, y); }

function nextName() {
  const alphabet = 'abcdefghijklmnopqrstuvwxyz';
  for (const c of alphabet) if (!nodes.find(n => n.id === c)) return c;
  return 'x' + (nodes.length + 1);
}

function resetAll() { nodes.length = 0; edges.length = 0; sourceId = null; updateSourceList(); draw(); }

function updateSourceList() {
  sourceSelect.innerHTML = '';
  const opt = document.createElement('option');
  opt.value = ''; opt.textContent = '— Select —';
  sourceSelect.appendChild(opt);
  for (const n of nodes) {
    const o = document.createElement('option');
    o.value = n.id; o.textContent = n.id;
    if (n.id === sourceId) o.selected = true;
    sourceSelect.appendChild(o);
  }
  runDijkstra();
}
sourceSelect.onchange = () => { sourceId = sourceSelect.value; runDijkstra(); };

function runDijkstra() {
  if (!sourceId) { resultBody.innerHTML = ''; return; }
  const dist = {}, prev = {}, visited = new Set();
  nodes.forEach(n => dist[n.id] = Infinity);
  dist[sourceId] = 0;
  while (visited.size < nodes.length) {
    let u = null, best = Infinity;
    for (const n of nodes) if (!visited.has(n.id) && dist[n.id] < best)
      { best = dist[n.id]; u = n.id; }
    if (!u) break;
    visited.add(u);
    for (const e of edges) {
      const [a,b] = [e.a, e.b];
      if (a !== u && b !== u) continue;
      const v = (a === u ? b : a);
      if (visited.has(v)) continue;
      const alt = dist[u] + e.w;
      if (alt < dist[v]) { dist[v] = alt; prev[v] = u; }
    }
  }
  const rows = nodes.map(n => {
    const d = dist[n.id] === Infinity ? '∞' : dist[n.id];
    const path = buildPath(prev, n.id).join('→');
    return `<tr><td>${n.id}</td><td>${d}</td><td>${path}</td></tr>`;
  }).join('');
  resultBody.innerHTML = rows;
}

function buildPath(prev, t) { const p = []; let cur = t; while (cur) { p.unshift(cur); cur = prev[cur]; } return p; }

function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.lineWidth = 2;

  for (const e of edges) {
    const n1 = nodes.find(n => n.id === e.a);
    const n2 = nodes.find(n => n.id === e.b);
    if (!n1 || !n2) continue;
    ctx.strokeStyle = "#333a56";
    ctx.beginPath();
    ctx.moveTo(n1.x, n1.y);
    ctx.lineTo(n2.x, n2.y);
    ctx.stroke();
    const mx = (n1.x + n2.x)/2, my = (n1.y + n2.y)/2;
    ctx.fillStyle = "#a78bfa";
    ctx.fillRect(mx - 12, my - 8, 24, 16);
    ctx.fillStyle = "#0b0f1a";
    ctx.font = "12px sans-serif";
    ctx.fillText(e.w, mx - 4, my + 4);
  }

  if (linking) {
    const from = nodes.find(n => n.id === linking.from);
    if (from) {
      ctx.strokeStyle = "#a78bfa";
      ctx.setLineDash([5,5]);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(linking.x, linking.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  for (const n of nodes) {
    ctx.fillStyle = "#171d34";
    ctx.strokeStyle = "#2a3358";
    ctx.beginPath();
    ctx.arc(n.x, n.y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = (n.id === sourceId) ? "#a78bfa" : "#d1d5db";
    ctx.fillText(n.id, n.x - 4, n.y + 4);
  }

  runDijkstra();
}

function pointLineDist(p, a, b) {
  const A = p.x - a.x, B = p.y - a.y, C = b.x - a.x, D = b.y - a.y;
  const dot = A*C + B*D, len2 = C*C + D*D;
  let t = dot / len2;
  if (t < 0) t = 0; else if (t > 1) t = 1;
  const x = a.x + t*C, y = a.y + t*D;
  return Math.hypot(p.x - x, p.y - y);
}
</script>
</body>
</html>
